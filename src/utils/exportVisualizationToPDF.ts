import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';

export interface ExportOptions {
  filename?: string;
  title?: string;
  userName?: string;
}

const cleanTitle = (title: string): string => {
  let cleaned = title;

  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = title;
  cleaned = tempDiv.textContent || tempDiv.innerText || title;

  cleaned = cleaned.replace(/[\u{1F300}-\u{1F9FF}]/gu, '');
  cleaned = cleaned.replace(/[\u{2600}-\u{26FF}]/gu, '');
  cleaned = cleaned.replace(/[\u{2700}-\u{27BF}]/gu, '');
  cleaned = cleaned.replace(/[^\x00-\x7F]/g, '');

  cleaned = cleaned.replace(/^[^a-zA-Z0-9]+/, '');

  cleaned = cleaned.trim();

  if (cleaned.length > 80) {
    cleaned = cleaned.substring(0, 80) + '...';
  }

  return cleaned || 'Visualization Report';
};

const addHeader = (
  pdf: jsPDF,
  cleanedTitle: string,
  userName: string,
  pageWidth: number,
  isFirstPage: boolean = true
): number => {
  if (isFirstPage) {
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(20);
    const titleLines = pdf.splitTextToSize(cleanedTitle, pageWidth - 30);
    pdf.text(titleLines, pageWidth / 2, 18, { align: 'center' });

    const titleHeight = 18 + (titleLines.length - 1) * 7;

    pdf.setFontSize(11);
    pdf.setTextColor(156, 163, 175);
    const currentDate = new Date().toLocaleString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
    pdf.text(`Generated: ${currentDate}`, pageWidth / 2, titleHeight + 10, { align: 'center' });
    pdf.text(`User: ${userName}`, pageWidth / 2, titleHeight + 17, { align: 'center' });

    pdf.setDrawColor(75, 85, 99);
    pdf.setLineWidth(0.5);
    pdf.line(15, titleHeight + 22, pageWidth - 15, titleHeight + 22);

    return titleHeight + 28;
  } else {
    pdf.setFontSize(13);
    pdf.setTextColor(156, 163, 175);
    pdf.text(cleanedTitle, pageWidth / 2, 14, { align: 'center' });

    pdf.setDrawColor(75, 85, 99);
    pdf.setLineWidth(0.3);
    pdf.line(15, 19, pageWidth - 15, 19);

    return 25;
  }
};

const addFooter = (pdf: jsPDF, pageWidth: number, pageHeight: number, pageNum: number, totalPages: number): void => {
  pdf.setFontSize(10);
  pdf.setTextColor(107, 114, 128);
  pdf.text(
    'Generated by Astra Intelligence - RocketHub',
    pageWidth / 2,
    pageHeight - 12,
    { align: 'center' }
  );

  pdf.setFontSize(9);
  pdf.text(
    `Page ${pageNum} of ${totalPages}`,
    pageWidth / 2,
    pageHeight - 6,
    { align: 'center' }
  );
};

const findBestBreakPoint = (
  canvas: HTMLCanvasElement,
  startY: number,
  idealEndY: number,
  searchRange: number = 100
): number => {
  const ctx = canvas.getContext('2d');
  if (!ctx) return idealEndY;

  const searchStart = Math.max(startY, idealEndY - searchRange);
  const searchEnd = Math.min(canvas.height, idealEndY + searchRange);

  let bestBreak = idealEndY;
  let maxWhiteSpace = 0;

  for (let y = searchStart; y < searchEnd; y += 2) {
    const imageData = ctx.getImageData(0, y, canvas.width, 1);
    const pixels = imageData.data;

    let whitePixels = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      const r = pixels[i];
      const g = pixels[i + 1];
      const b = pixels[i + 2];

      if (r > 200 && g > 200 && b > 200) {
        whitePixels++;
      } else if (r < 50 && g < 50 && b < 80) {
        whitePixels++;
      }
    }

    const whiteRatio = whitePixels / (canvas.width / 4);
    if (whiteRatio > maxWhiteSpace) {
      maxWhiteSpace = whiteRatio;
      bestBreak = y;
    }
  }

  return maxWhiteSpace > 0.7 ? bestBreak : idealEndY;
};

export const exportVisualizationToPDF = async (
  element: HTMLElement,
  options: ExportOptions = {}
): Promise<void> => {
  try {
    const {
      filename = 'visualization',
      title = 'Visualization Report',
      userName = 'User'
    } = options;

    const cleanedTitle = cleanTitle(title);

    const originalWidth = element.scrollWidth;
    const originalHeight = element.scrollHeight;

    const targetWidth = 2400;
    const scale = Math.min(targetWidth / originalWidth, 3);

    const canvas = await html2canvas(element, {
      scale: scale,
      useCORS: true,
      logging: false,
      backgroundColor: '#1f2937',
      windowWidth: originalWidth,
      windowHeight: originalHeight,
      imageTimeout: 0,
      width: originalWidth,
      height: originalHeight,
      letterRendering: true,
      allowTaint: true,
      onclone: (clonedDoc) => {
        const clonedElement = clonedDoc.querySelector('body > div:last-child') as HTMLElement;
        if (clonedElement) {
          clonedElement.style.width = '1200px';
          clonedElement.style.maxWidth = '1200px';

          const allTextElements = clonedElement.querySelectorAll('*');
          allTextElements.forEach((el: Element) => {
            const htmlEl = el as HTMLElement;
            const computedStyle = window.getComputedStyle(htmlEl);

            if (computedStyle.display === 'flex' || computedStyle.display === 'inline-flex') {
              htmlEl.style.display = 'block';
            }

            htmlEl.style.whiteSpace = 'normal';
            htmlEl.style.letterSpacing = 'normal';
            htmlEl.style.wordSpacing = 'normal';
          });
        }
      }
    });

    const pdf = new jsPDF({
      orientation: 'landscape',
      unit: 'mm',
      format: 'a3'
    });

    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();

    const marginSides = 15;
    const marginBottom = 25;
    const contentWidth = pageWidth - (marginSides * 2);

    const imgWidthMm = contentWidth;
    const imgHeightMm = (canvas.height * contentWidth) / canvas.width;

    const imgData = canvas.toDataURL('image/png', 1.0);

    let yOffset = 0;
    let pageNum = 1;
    const pages: Array<{ isFirst: boolean; yStart: number; yEnd: number; height: number }> = [];

    while (yOffset < imgHeightMm) {
      const isFirstPage = pageNum === 1;
      const headerHeight = isFirstPage ? 45 : 25;
      const availableHeight = pageHeight - headerHeight - marginBottom;

      const idealEndY = yOffset + availableHeight;

      let actualEndY: number;
      if (idealEndY >= imgHeightMm) {
        actualEndY = imgHeightMm;
      } else {
        const idealEndYPx = (idealEndY / imgHeightMm) * canvas.height;
        const startYPx = (yOffset / imgHeightMm) * canvas.height;

        const bestBreakPx = findBestBreakPoint(
          canvas,
          startYPx,
          idealEndYPx,
          200
        );

        actualEndY = (bestBreakPx / canvas.height) * imgHeightMm;
      }

      const heightForThisPage = actualEndY - yOffset;

      pages.push({
        isFirst: isFirstPage,
        yStart: yOffset,
        yEnd: actualEndY,
        height: heightForThisPage
      });

      yOffset = actualEndY;
      pageNum++;
    }

    const totalPages = pages.length;

    pages.forEach((pageInfo, index) => {
      if (index > 0) {
        pdf.addPage();
      }

      pdf.setFillColor(31, 41, 55);
      pdf.rect(0, 0, pageWidth, pageHeight, 'F');

      const headerHeight = addHeader(pdf, cleanedTitle, userName, pageWidth, pageInfo.isFirst);

      const sy = (pageInfo.yStart / imgHeightMm) * canvas.height;
      const sh = ((pageInfo.yEnd - pageInfo.yStart) / imgHeightMm) * canvas.height;
      const sw = canvas.width;

      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = sw;
      tempCanvas.height = sh;
      const tempCtx = tempCanvas.getContext('2d');

      if (tempCtx) {
        tempCtx.drawImage(canvas, 0, sy, sw, sh, 0, 0, sw, sh);
        const pageImgData = tempCanvas.toDataURL('image/png', 1.0);

        pdf.addImage(
          pageImgData,
          'PNG',
          marginSides,
          headerHeight,
          imgWidthMm,
          pageInfo.height,
          undefined,
          'FAST'
        );
      }

      addFooter(pdf, pageWidth, pageHeight, index + 1, totalPages);
    });

    const sanitizedFilename = filename
      .replace(/[^a-z0-9]/gi, '-')
      .replace(/-+/g, '-')
      .toLowerCase();

    const timestamp = new Date().toISOString().split('T')[0];
    const finalFilename = `${sanitizedFilename}-${timestamp}.pdf`;

    pdf.save(finalFilename);

    return Promise.resolve();
  } catch (error) {
    console.error('Failed to export PDF:', error);
    throw new Error('Failed to generate PDF. Please try again.');
  }
};
